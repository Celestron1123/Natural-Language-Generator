package comprehensive;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Random;

/**
 * A supplemental class to the TextGenerator class designed to process a given
 * Markov Chain from a body of text. From a Markov Chain, a unique phrase is
 * generated an returned.
 * 
 * @authors - Elijah Potter & William Ngo
 * @version April 17, 2024
 */
public class TextGeneratorModel {

	/**
	 * A method designed to create a phrase from a Markov Chain. The phrase is
	 * generated by stringing together words that follow one another in the original
	 * body of text, and is determined by random chance (with more frequent words
	 * getting greater probability). The phrase starts with a given seed.
	 * 
	 * @param file    - The file containing the body of text
	 * @param seed    - The starting word.
	 * @param kString - However many words are desired in the final phrase
	 * @throws NoSuchElementException If the file is empty
	 * @throws FileNotFoundException  If the file can't be found
	 */
	public static void createPhrase(String file, String seed, String kString)
			throws NoSuchElementException, FileNotFoundException {

		int k = Integer.parseInt(kString);
		k--;
		HashMap<String, ArrayList<String>> chain = MarkovChain.generateText(file);
		System.out.print(seed);
		String tempWord = seed;
		Random rand = new Random();
		int index = 0;

		for (int i = 0; i < k; i++) {
			try {
				index = rand.nextInt(chain.get(tempWord).size());
				tempWord = chain.get(tempWord).get(index);
				System.out.print(" " + tempWord);
			} catch (NullPointerException e) {
				tempWord = seed;
				System.out.print(" " + tempWord);
			}

		}

	}

	/**
	 * A method designed to create a phrase from a Markov Chain. The phrase is
	 * generated by stringing together words that follow one another in the original
	 * body of text, and is determined by whichever word most frequently follows
	 * another. The phrase starts with a given seed.
	 * 
	 * @param file    - The file containing the body of text
	 * @param seed    - The starting word.
	 * @param kString - However many words are desired in the final phrase
	 * @throws NoSuchElementException If the file is empty
	 * @throws FileNotFoundException  If the file can't be found
	 */
	public static void createOnePhrase(String file, String seed, String kString)
			throws NoSuchElementException, FileNotFoundException {

		int k = Integer.parseInt(kString);
		k--;
		HashMap<String, HashMap<String, Integer>> chain = MarkovChain.generateOneText(file);
		System.out.print(seed);
		String tempWord = seed;

		for (int i = 0; i < k; i++) {
			try {
				int maxCount = 0;
				String maxKey = null;
				for (Entry<String, Integer> pair : chain.get(tempWord).entrySet()) {
					if (maxCount < pair.getValue()) {
						maxKey = pair.getKey();
						maxCount = pair.getValue();
					} else if (maxCount == pair.getValue()) {
						if (maxKey.compareTo(pair.getKey()) > 0)
							maxKey = pair.getKey();

					}
				}

				tempWord = maxKey;
				System.out.print(" " + tempWord);
			} catch (NullPointerException e) {
				tempWord = seed;
				System.out.print(" " + tempWord);
			}

		}

	}

	/**
	 * A method that returns the list of possible words following the given word.
	 * Will only print as many words as specified by kString.
	 * 
	 * @param file    - The body of text
	 * @param seed    - The word to process
	 * @param kString - The amount of words to be returned
	 * @throws NoSuchElementException If the file is empty
	 * @throws FileNotFoundException  If the file can't be found
	 */
	public static void findKMostProbable(String file, String seed, String kString)
			throws NoSuchElementException, FileNotFoundException {

		int k = Integer.parseInt(kString);
		HashMap<String, ArrayList<String>> chain = MarkovChain.generateText(file);
		HashMap<String, Integer> tally = new HashMap<>();
		String tempWord = seed;
		int check = 0;

		for (int j = 0; j < chain.get(tempWord).size(); j++) {
			String key = chain.get(tempWord).get(j);
			if (tally.containsKey(key)) {
				int count = tally.get(key);
				count++;
				tally.put(key, count);
			} else {
				tally.put(key, 1);
			}
		}

		for (int i = 0; i < k; i++) {
			int maxCount = 0;
			String maxKey = null;
			for (Entry<String, Integer> pair : tally.entrySet()) {
				if (maxCount < pair.getValue()) {
					maxKey = pair.getKey();
					maxCount = pair.getValue();
				} else if (maxCount == pair.getValue()) {
					if (maxKey.compareTo(pair.getKey()) > 0)
						maxKey = pair.getKey();

				}
			}

			tally.remove(maxKey);
			if (check == 0)
				System.out.print(maxKey);
			else
				System.out.print(" " + maxKey);
			if (tally.isEmpty())
				break;
			check++;
		}

	}

}
