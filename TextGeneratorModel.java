package comprehensive;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Random;

/**
 * A supplemental class to the TextGenerator class designed to process a given
 * Markov Chain from a body of text. From a Markov Chain, a unique phrase is
 * generated an returned.
 * 
 * @authors - Elijah Potter & William Ngo
 * @version April 23, 2024
 */
public class TextGeneratorModel {

	/**
	 * A method designed to create a phrase from a Markov Chain. The phrase is
	 * generated by stringing together words that follow one another in the original
	 * body of text, and is determined by random chance (with more frequent words
	 * getting greater probability). The phrase starts with a given seed.
	 * 
	 * @param file    - The file containing the body of text
	 * @param seed    - The starting word.
	 * @param kString - However many words are desired in the final phrase
	 * @throws NoSuchElementException If the file is empty
	 * @throws FileNotFoundException  If the file can't be found
	 */
	public static void createPhrase(String file, String seed, String kString)
			throws NoSuchElementException, FileNotFoundException {

		int k = Integer.parseInt(kString);
		k--;
		HashMap<String, ArrayList<String>> chain = MarkovChain.generateText(file);
		System.out.print(seed);
		String tempWord = seed;
		Random rand = new Random();
		int index = 0;

		for (int i = 0; i < k; i++) {
			try {
				// Pick a random index to access
				index = rand.nextInt(chain.get(tempWord).size());
				tempWord = chain.get(tempWord).get(index);
				System.out.print(" " + tempWord);
			} catch (NullPointerException e) {
				tempWord = seed;
				System.out.print(" " + tempWord);
			}

		}

	}	

	/**
	 * A method designed to create a phrase from a Markov Chain. The phrase is
	 * generated by stringing together words that follow one another in the original
	 * body of text, and is determined by whichever word most frequently follows
	 * another. The phrase starts with a given seed.
	 * 
	 * @param file    - The file containing the body of text
	 * @param seed    - The starting word.
	 * @param kString - However many words are desired in the final phrase
	 * @throws NoSuchElementException If the file is empty
	 * @throws IOException 
	 */
	public static void createOnePhrase(String file, String seed, String kString)
			throws NoSuchElementException, IOException {

		int k = Integer.parseInt(kString);
		k--;
		HashMap<String, HashMap<String, Integer>> chain = MarkovChain.generateOneTextAlternative(file);
		System.out.print(seed);
		String tempWord = seed;

		for (int i = 0; i < k; i++) {
			try {
				int maxCount = 0;
				String maxKey = null;
				// Iterate through each pair to find highest integer value 
				for (Entry<String, Integer> pair : chain.get(tempWord).entrySet()) {
					if (maxCount < pair.getValue()) {
						maxKey = pair.getKey();
						maxCount = pair.getValue();
					} else if (maxCount == pair.getValue()) {
						if (maxKey.compareTo(pair.getKey()) > 0)
							maxKey = pair.getKey();
					}
				}

				tempWord = maxKey;
				System.out.print(" " + tempWord);
			} catch (NullPointerException e) {
				tempWord = seed;
				System.out.print(" " + tempWord);
			}

		}

	}

	/**
	 * A method that returns the list of possible words following the given word.
	 * Will only print as many words as specified by kString.
	 * 
	 * @param file    - The body of text
	 * @param seed    - The word to process
	 * @param kString - The amount of words to be returned
	 * @throws NoSuchElementException If the file is empty
	 * @throws IOException
	 */
	public static void findKMostProbable(String file, String seed, String kString)
			throws NoSuchElementException, IOException {

		int k = Integer.parseInt(kString);
		HashMap<String, HashMap<String, Integer>> chain = MarkovChain.generateOneTextAlternative(file);
		int check = 0;

		for (int i = 0; i < k; i++) {
			int maxCount = 0;
			String maxKey = null;
			// Iterate through each pair to find highest integer value
			for (Entry<String, Integer> pair : chain.get(seed).entrySet()) {
				if (maxCount < pair.getValue()) {
					maxKey = pair.getKey();
					maxCount = pair.getValue();
				} else if (maxCount == pair.getValue()) {
					if (maxKey.compareTo(pair.getKey()) > 0)
						maxKey = pair.getKey();
				}
			}

			chain.get(seed).remove(maxKey);
			// This is to check whether or not this is the first pass
			if (check == 0)
				System.out.print(maxKey);
			else
				System.out.print(" " + maxKey);
			// Stop, if the chain is empty
			if (chain.get(seed).isEmpty())
				break;
			check++;
		}

	}

}
